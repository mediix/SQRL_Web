import osimport datetimeimport timeimport base64import boto3import pyqrcodeimport jsonfrom model import Challengefrom backendBaseHandler import backendBaseHandlerclass sqrlBackendHandler(backendBaseHandler):    """    sqrlBackendHandler API v1.    sqrlBackendHandler inherits from the backendBaseHandler abstract class.    inheriting methods needs to be overridden.    """    s3_client = boto3.client('s3')    bucket = 'sqrlcontainer'    key = 'challenges/'    def __init__(self):        super(self.__class__, self).__init__()    def on_generate(self, request_body, request_params):        """        :param request_body:        :param request_params:        """        pass    def on_processing_error(self, event, context, err):        """        :param event:        :param context:        :param err:        """        return self.build_response('404', None, None, None, err)    def process_request(self, event, context):        """        :param event:        :param context:        :return:        """        try:            # response = None            if event['body']['operation'] == "generate":                file_name, qrcode_path = self.generate_challenge()                db_id = self.dynamodb(file_name, qrcode_path)                response_type = 'generate'            if event['body']['operation'] == "authenticate":                response_type = 'authenticate'                self.logger.info("got to authenticate")                received_data = self.unpack_client_data(event['body']['params'])                self.authenticate_login(received_data)        except Exception as err:            response = self.on_processing_error(event, context, err)        else:            self.logger.info("Successfully Created Response")            response = self.build_response('200', qrcode_path, response_type, db_id, None)        return response    # -------- Helpers to build the response type for a request ----------    def build_response(self, status_code, qr_path, response_type, db_id, err_msg=None):        """        :param status_code:        :param db_id:        :param qr_path:        :type err_msg:        :param response_type: success, fail, error        :return:        """        return {                "status_code": status_code,                "response_type": response_type,                "qrcode": qr_path,                "error_message": err_msg        }    # Helper functions to generate, record, and save the QRcodes    def generate_challenge(self):        """        """        self.logger.info("Beginning to generate QR code")        # QR Code data        qr_data = base64.urlsafe_b64encode(os.urandom(6))        qr_link = 'sqrl://2oc3yo4sj9.execute-api.us-west-2.amazonaws.com/dev?nut='        qr_sfn = "&sfn=CSCI152"        qr_content = qr_link + qr_data + qr_sfn        print(qr_content)        #qr_data = qr_link + qr_challenge# + sfn        self.logger.info('QR Data: ' + qr_content)        # Create a qr code image        img = pyqrcode.create(qr_content)        # Save the img in a temporary location        temp_folder = '/tmp/'        file_name = qr_data + '.svg'        img.svg(temp_folder + file_name, scale=6)        temp_path = temp_folder + file_name        target_path = self.key + file_name        try:            self.s3_client.upload_file(temp_path, self.bucket, target_path,                ExtraArgs={'ContentType': 'image/svg+xml', 'ACL': 'public-read'})            url = '{}/{}/{}'.format(self.s3_client.meta.endpoint_url, self.bucket, target_path)            return file_name, url        except Exception as err:            self.logger.info("Error uploading qrcode: %s" % err)            return err    def dynamodb(self, qr_code, s3_file_path):        """        :param qr_code:        :param s3_file_path:        """        now = datetime.datetime.now()        expiry = now + datetime.timedelta(minutes=10)        #        try:            code = Challenge(qr_code,                             readable_date_created=now.strftime("%Y-%m-%d %U:%M:%S"),                             date_created=int(round(time.time() * 1000)),                             readable_expiry=expiry.strftime("%Y-%m-%d %U:%M:%S"),                             expiry=int(round((time.time() + 600) * 1000)),                             s3_file_path=s3_file_path.encode('utf-8'),                             is_expired=0)            code.save()        except Exception as err:            self.logger.info("Error creating a database entry: %s" % err)        else:            self.logger.info("Successfully created a database entry")            return code.qrcode    def get_padded_string(self, input_s):        return input_s + '=' * (-len(input_s) % 4)    # return a dict of the parameters that the client posted to the server    def unpack_client_data(self, raw_data):        clientData = {}        # get the individual strings        s_client = raw_data['client'].encode('utf8').strip()        s_server = raw_data['server'].encode('utf8').strip()        s_ids = raw_data['ids'].encode('utf8').strip()        s_pids = raw_data['pids'].encode('utf8').strip()        s_urs = raw_data['urs'].encode('utf8').strip()        # get the padded strings        s_client = self.get_padded_string(s_client)        s_server = self.get_padded_string(s_server)        s_ids = self.get_padded_string(s_ids)        s_pids = self.get_padded_string(s_pids)        s_urs = self.get_padded_string(s_urs)        # decode each member        d_client = base64.urlsafe_b64decode(s_client)        d_server = base64.urlsafe_b64decode(s_server)        d_ids = base64.urlsafe_b64decode(s_ids)        d_pids = base64.urlsafe_b64decode(s_pids)        d_urs = base64.urlsafe_b64decode(s_urs)        # separate and decode the client        cData = {}        for pair in d_client.split():            pData = pair.split('=')            par = self.get_padded_string(pData[1][1:-1]) # remove '{' and '}'            par = base64.urlsafe_b64decode(par)            cData[pData[0]] = par        # fill in what we know        clientData['client'] = cData        clientData['server'] = d_server        clientData['ids'] = d_ids        clientData['pids'] = d_pids        clientData['urs'] = d_urs        return clientData    def authenticate_login(self, received_data):        # Get the client idk        client_idk = received_data['client']['idk']        self.logger.info("Received login request from user: " + client_idk)        par_server = received_data['server']        self.logger.info("Server: " + par_server)        # Extract the qr data from the server parameter        url_query = par_server.split("?")[1]        url_params = url_query.split("&")        # Go through the params to find the nut        url_nut = ''        for each in url_params:            pair = each.split("=")            if pair[0] == "nut":                url_nut = pair[1]        self.logger.info("Received nut: " + url_nut)        # Check that the NUT exists in the database        try:            qrNut = Challenge.qrcode_index.query(url_nut).next()            self.logger.info("Found entry for: " + url_nut)        except:            self.logger.info("Did not find request")            return sqrlTifValues.CLIENT_FAILURE | sqrlTifValues.COMMAND_FAILED        # check that the QR code isn't already used        if qrNut.user_logged_in is not None:            self.logger.info("qr code previously used")            return sqrlTifValues.CLIENT_FAILURE | sqrlTifValues.BAD_ID_ASSOCIATION | sqrlTifValues.COMMAND_FAILED        # check expiration time        time_now = int(round((time.time()) * 1000))        if time_now > qrNut.expiry:            self.logger.info("Qr Code time expired")            qrNut.update_item('is_expired', 1, action='put')            qrNut.update_item('user_logged_in', 'expired', action='put')            return sqrlTifValues.TRANSIENT_ERROR | sqrlTifValues.COMMAND_FAILED        else:            self.logger.info('Qr code time OK')        # if everything passes then accept the user        authUser = str(received_data['client']['idk'])        self.logger.info("Logged in user: " + authUser)        qrNut.update_item('user_logged_in', authUser, action='put')        qrNut.update_item('expiry', 0, action='put')        return sqrlTifValues.ID_MATCH