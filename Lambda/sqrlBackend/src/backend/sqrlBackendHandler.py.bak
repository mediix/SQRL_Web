import osimport datetimeimport timeimport base64import boto3import pyqrcodeimport jsonfrom model import Challengefrom backendBaseHandler import backendBaseHandlerclass sqrlBackendHandler(backendBaseHandler):    """    sqrlBackendHandler API v1.    sqrlBackendHandler inherits from the backendBaseHandler abstract class.    inheriting methods needs to be overridden.    """    s3_client = boto3.client('s3')    bucket = 'sqrlcontainer'    key = 'challenges/'    def __init__(self):        super(self.__class__, self).__init__()    def on_generate(self, request_body, request_params):        """        :param request_body:        :param request_params:        """        pass    def on_processing_error(self, event, context, err):        """        :param event:        :param context:        :param err:        """        return self.build_response('404', None, None, None, err)    def process_request(self, event, context):        """        :param event:        :param context:        :return:        """        try:            # response = None            if event['body']['operation'] == "generate":                file_name, qrcode_path = self.generate_challenge()                db_id = self.dynamodb(file_name, qrcode_path)                response_type = 'generate'            if event['body']['operation'] == "authenticate":                response_type = 'authenticate'                self.logger.info("got to authenticate")                received_data = self.unpack_client_data(event['body']['params'])                self.authenticate_login(received_data)        except Exception as err:            response = self.on_processing_error(event, context, err)        else:            self.logger.info("Successfully Created Response")            #response = self.build_response('200', qrcode_path, response_type, db_id, None)            response = {                "result": {                    "status_code": 200,                    "response_type": response_type,                }            }        return response    # -------- Helpers to build the response type for a request ----------    def build_response(self, status_code, qr_path, response_type, db_id, err_msg=None):        """        :param status_code:        :param db_id:        :param qr_path:        :type err_msg:        :param response_type: success, fail, error        :return:        """        return {            "result": {                    "status_code": status_code,                    "response_type": response_type,                    "qrcode_path": qr_path,                    "database_entry": db_id,                    "error_message": err_msg                    }            }    # Helper functions to generate, record, and save the QRcodes    def generate_challenge(self):        """        """        self.logger.info("Beginning to generate QR code")        # QR Code data        qr_data = base64.urlsafe_b64encode(os.urandom(6))        qr_link = 'sqrl://2oc3yo4sj9.execute-api.us-west-2.amazonaws.com/dev?nut='        qr_sfn = "&sfn=CSCI152"        qr_content = qr_link + qr_data + qr_sfn        print(qr_content)        #qr_data = qr_link + qr_challenge# + sfn        self.logger.info('QR Data: ' + qr_content)        # Create a qr code image        img = pyqrcode.create(qr_content)        # Save the img in a temporary location        temp_folder = '/tmp/'        file_name = qr_data + '.svg'        img.svg(temp_folder + file_name, scale=6)        temp_path = temp_folder + file_name        target_path = self.key + file_name        try:            self.s3_client.upload_file(temp_path, self.bucket, target_path)            params = {'Bucket': self.bucket, 'Key': target_path}            return file_name, self.s3_client.generate_presigned_url('get_object', Params=params)        except Exception as err:            self.logger.info("Error uploading qrcode: %s" % err)            return err    def dynamodb(self, qr_code, s3_file_path):        """        :param qr_code:        :param s3_file_path:        """        now = datetime.datetime.now()        expiry = now + datetime.timedelta(minutes=10)        #        try:            code = Challenge(qr_code,                             readable_date_created=now.strftime("%Y-%m-%d %U:%M:%S"),                             date_created=int(round(time.time() * 1000)),                             readable_expiry=expiry.strftime("%Y-%m-%d %U:%M:%S"),                             expiry=int(round((time.time() + 600) * 1000)),                             s3_file_path=s3_file_path.encode('utf-8'),                             user_logged_in='',                             is_expired=0)            code.save()        except Exception as err:            self.logger.info("Error creating a database entry: %s" % err)        else:            self.logger.info("Successfully created a database entry")            return code.qrcode        def get_padded_string(self, input_s):        return input_s + '=' * (-len(input_s) % 4)                # return a dict of the parameters that the client posted to the server    def unpack_client_data(self, raw_data):        clientData = {}                # get the individual strings        s_client = raw_data['client'].encode('utf8').strip()        s_server = raw_data['server'].encode('utf8').strip()        s_ids = raw_data['ids'].encode('utf8').strip()        s_pids = raw_data['pids'].encode('utf8').strip()        s_urs = raw_data['urs'].encode('utf8').strip()                # get the padded strings        s_client = self.get_padded_string(s_client)        s_server = self.get_padded_string(s_server)        s_ids = self.get_padded_string(s_ids)        s_pids = self.get_padded_string(s_pids)        s_urs = self.get_padded_string(s_urs)                        # decode each member        d_client = base64.urlsafe_b64decode(s_client)        d_server = base64.urlsafe_b64decode(s_server)        d_ids = base64.urlsafe_b64decode(s_ids)        d_pids = base64.urlsafe_b64decode(s_pids)        d_urs = base64.urlsafe_b64decode(s_urs)                # separate and decode the client        cData = {}                for pair in d_client.split():            pData = pair.split('=')            par = self.get_padded_string(pData[1][1:-1]) # remove '{' and '}'            par = base64.urlsafe_b64decode(par)            cData[pData[0]] = par                    # fill in what we know        clientData['client'] = cData        clientData['server'] = d_server        clientData['ids'] = d_ids        clientData['pids'] = d_pids        clientData['urs'] = d_urs                return clientData            def authenticate_login(self, received_data):        # Get the client idk        client_idk = received_data['client']['idk']        self.logger.info("Received login request from user: " + client_idk)                par_server = received_data['server']        self.logger.info("Server: " + par_server)                # Extract the qr data from the server parameter        url_query = par_server.split("?")[1]        url_params = url_query.split("&")                # Go through the params to find the nut        url_nut = ''        for each in url_params:            pair = each.split("=")            if pair[0] == "nut":                url_nut = pair[1]                        self.logger.info("Found nut: " + url_nut)                        # Find the nut in the database        Challenge.qrcode_index.query(url_nut)